<!--
 * -------------------------------------------------------------------
 *  File name:      index.html
 *  Project name:   Breakout in JavaScript
 * -------------------------------------------------------------------
 *      Author's name and email:	Michael Ng, mwnmwn07@gmail.com			
 *        A personal project for ETSU ACM Game Jam Spring 2023.
 *
 *      Creation Date:              3/9/2023
 *      Last Modified:              3/20/2023
 *      Description:                This webpage serves as the 
 *                                  index for the breakout game.
 *      Tutorial Used:             https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript
 * -------------------------------------------------------------------
-->    

<!DOCTYPE html>
    <head>
        <meta charset="utf-8" />
        <title>Super Breakout</title>

        <!-- Styling used for certain elements on the webpage. -->
        <style>
            * {
                padding: 0;
                margin: 0;
            }
            canvas {
                background: #eee;
                display: block;
                margin: 0 auto;
            }
        </style>

    </head>
    
    <!-- The body will contain everything 
        that will show the breakout game. -->
    <!-- The field, oncontextmenu, disables the 
        context menu showing when the user right-clicks. -->
    <body>

        <!-- The Background Music - MLG Sniper Background Music -->
        <audio id="BackgroundMusic" autoplay="true" mutable="muted">
            <!-- <source src="MLG Sniper Background Music 2.mp3" type="audio/mpeg"> -->
            <source src="Energetic Hype Bass Chaos by Damtaro.mp3" type="audio/mpeg">
            This audio element is not supported.
        </audio>
        
        <!-- The Hitmarker Sound. A unique TOUCH! -->
        <audio id="HitmarkerSound">
            <source src="hitmarkersound.mp3" type="audio/mpeg">
            This audio element is not supported.
        </audio>
        
        <!-- The Hitmarker Sound. A unique TOUCH! -->
        <audio id="HitmarkerSound2">
            <source src="hitmarkersound.mp3" type="audio/mpeg">
            This audio element is not supported.
        </audio>
        
        <!-- The Hitmarker Sound. A unique TOUCH! -->
        <audio id="HitmarkerSound3">
            <source src="hitmarkersound.mp3" type="audio/mpeg">
            This audio element is not supported.
        </audio>
        
        <!-- The Hitmarker Sound. A unique TOUCH! -->
        <audio id="HitmarkerSound4">
            <source src="hitmarkersound.mp3" type="audio/mpeg">
            This audio element is not supported.
        </audio>
        
        <!-- The Hitmarker Sound. A unique TOUCH! -->
        <audio id="HitmarkerSound5">
            <source src="hitmarkersound.mp3" type="audio/mpeg">
            This audio element is not supported.
        </audio>
        
        <!-- The Hitmarker Sound. A unique TOUCH! -->
        <audio id="HitmarkerSound6">
            <source src="hitmarkersound.mp3" type="audio/mpeg">
            This audio element is not supported.
        </audio>
        
        <!-- A Sniper Sound. A unique TOUCH! -->
        <audio id="SniperSound">
            <source src="snipersound.mp3" type="audio/mpeg">
            This audio element is not supported.
        </audio>
        
        <!-- A Sniper Sound. A unique TOUCH! -->
        <audio id="SniperSound2">
            <source src="snipersound.mp3" type="audio/mpeg">
            This audio element is not supported.
        </audio>

        <!-- Create a canvas that is 480px wide and 320px high. -->
        <!-- This canvas can easily be referenced as myCanvas. -->
        <!-- <canvas id="myCanvas" width="480" height="320"> -->
        <canvas id="myCanvas" width="720" height="600"></canvas>


        <script>
            //Small note - everything inside script is commented with "//".

            /****************** VARIABLES *****************/
            //canvas will store a reference to the canvas element named myCanvas.
            const canvas = document.getElementById("myCanvas");

            //canvasContext will store the 2D rendering context.
            //This context will be used to paint on the Canvas.
            const canvasContext = canvas.getContext("2d");

            //console.log(Math.atan(3/5));

                /** Game Variables **/
                let score = 0;
                let lives = 3;
                let ballSpeed = 2;
                let frameCount = 0;
                let themeColor = "#000000";

                //womboCombo holds the amount of bricks the player's ball hits in one go.
                let womboCombo = 0;

                //The isPaused boolean will allow you to pause the game.
                let isPaused = false;

                //ballSpeedRemember acts as a remembering variable.
                //When the player pauses the game, ballSpeed is set to 0.
                //ballSpeedRemember will retain the ballSpeed before pause.
                let ballSpeedRemember = 0;
                let ballMoveXRemember = 0;
                let ballMoveYRemember = 0;

                //Automode determines if the paddle will always hit the paddle.
                let autoMode = false;
                //pwnMode determines if the ball will react to brick collisions.
                //If true, Newton's 3rd Law is ignored when the ball hits the bricks.
                let pwnMode = false;

                //When enabled, the ball will automatically target stray bricks.
                let snipeMode = false;
                let brickTarget = null;

                /** Ball Variables **/
                const ballRadius = 10;

                let ballX = canvas.width / 2;
                //Since ballMoveX is positive, it will move right.
                let ballMoveX = ballSpeed;

                let ballY = canvas.height - 30;
                //Since ballMoveY is negative, it will move up (not down).
                let ballMoveY = -ballSpeed;

                let ballColor = "#0095DD"
                let cyan = "#0095DD";
                let lgreen = "#3DED97";
                let green = "#03C04A";
                let dblue = "#211BF1";
                let purple = "#8F00FF";
                
            

                /** Paddle Variables **/
                const paddleHeight = 10;
                let paddleWidth = (canvas.width/6); //Originally 75.

                //paddleScore is a variable used to keep track of paddleSize.
                //It is named this because it uses score to increase the paddle's width.
                let paddleScore = score;
                let paddleX = (canvas.width - paddleWidth) / 2;

                let rightPressed = false;
                let leftPressed = false;



                /** Brick Variables **/
                const brickRowCount = 5;
                const brickColumnCount = 8;
                const brickWidth = 75;
                const brickHeight = 20;
                const brickPadding = 10;
                const brickOffsetTop = 30;
                const brickOffsetLeft = 20;
                let bricksLeft = brickRowCount * brickColumnCount;

                //We will hold all these bricks in a 2D array.
                const bricks = [];

                //Add bricks to the 2D array.
                for(let c = 0; c < brickColumnCount; c++)
                {
                    bricks[c] = [];
                    for(let r = 0; r < brickRowCount; r++)
                    {
                        bricks[c][r] = { x: 0, y: 0, status: 1 };
                    }
                }


                /** Resources **/
                var backgroundMusic = document.getElementById("BackgroundMusic");
                const hitmarker = new Image();
                hitmarker.src = "hitmarkersmall.png";
                    hitmarkerX = 0;
                    hitmarkerY = 0;
                const mlgbackground = new Image();
                mlgbackground.src = "mlgbackground.jpg";
                    mlgbackgroundX = 0;
                    mlgbackgroundY = 0;
                var hitsound = document.getElementById("HitmarkerSound");
                var hitsound2 = document.getElementById("HitmarkerSound2");
                var hitsound3 = document.getElementById("HitmarkerSound3");
                var hitsound4 = document.getElementById("HitmarkerSound4");
                var hitsound5 = document.getElementById("HitmarkerSound5");
                var hitsound6 = document.getElementById("HitmarkerSound6");

                var snipersound = document.getElementById("SniperSound");
                var snipersound2 = document.getElementById("SniperSound2");


            /****************** END VARIABLES *****************/
            /****************** FUNCTIONS *****************/

            //The draw function will update the canvas.
            //There is an async function, setInterval
            //defined in ASYNC FUNCTION CALLS.
            //That function will call draw() every 10 milliseconds.
            function draw() 
            {
                //clear the entire canvas before drawing again.
                //Takes in the top left coordinates and bottom right coordinates
                //and then clears the entire area in a rectangle shape.
                canvasContext.clearRect(0, 0, canvas.width, canvas.height);

                drawBackgroundImage();
                //call the drawBricks function to draw the Bricks.
                drawBricks();
                //call the drawBall function to draw the Ball.
                drawBall();
                //call the drawPaddle function to draw the Paddle.
                drawPaddle();
                //call the collisionDetection function to detect collision in the bricks.
                collisionDetection();
                //call the drawScore function to draw the score the player has.
                drawScore();
                //call the drawSpeed function to draw the speed the ball has.
                drawSpeed();
                //call the drawLives function to draw the amount of lives the player has.
                drawLives();
                //call the drawLives function to draw the bricks left on screen.
                drawBricksLeft();
                //call the drawMLGBooleans function to draw the bricks left on screen.
                drawMLGBooleans();


                /***** Ball Logic *****/
                    //If the ball goes to the left of the left border of the screen,
                    //or to the right of the right border of the screen.
                    if(ballX + ballMoveX < ballRadius || ballX + ballMoveX > canvas.width - ballRadius)
                    {
                        ballMoveX = -ballMoveX;
                    }
                    //If the ball goes above the top border of the screen,
                    //or below the bottom border of the screen.
                    if(ballY + ballMoveY < ballRadius)
                    {
                        ballMoveY = -ballMoveY;
                    }
                    else if(ballY + ballMoveY > canvas.height - paddleHeight - ballRadius)
                    {
                        //Note that the above code deviates from the source code.
                        //I did this because the ball bouncing off the wall instead of
                        // the paddle bothered me, so I made some changes.
                        if(ballX > paddleX && ballX < paddleX + paddleWidth)
                        {
                            ballMoveY = -ballMoveY;
                        }
                        else if(ballY + ballRadius > canvas.height)
                        {
                            //We display an alert message saying "GAME OVER".
                            lives--;
                            if(!lives)
                            {
                                alert("GAME OVER");
                                document.location.reload();
                                //clearInterval(interval);
                            }
                            else
                            {
                                ballX = canvas.width / 2;
                                ballY = canvas.height - 30;

                                //We want to make sure the minimum value of ballSpeed is 1.
                                //This statement ensures that the minimum value is met when the ball goes out of bounds.
                                if(ballSpeed >= 3)
                                {
                                    ballSpeed -= 2;
                                }
                                else 
                                {
                                    ballSpeed = 1;
                                }

                                //Make the ball go right.
                                ballMoveX = Math.abs(ballSpeed);
                                //Make the ball go up.
                                ballMoveY = -Math.abs(ballSpeed);

                                //reset the position of the paddle.
                                paddleX = (canvas.width - paddleWidth) / 2;
                            }
                        }
                    }
                    
                    //SnipeMode will move the ball to a brick rather than an arbitrary direction.
                    if(!snipeMode)
                    {
                        //Move the ball horizontally according to ballMoveX.
                        ballX += ballMoveX;
                        //Move the ball vertically according to ballMoveY.
                        ballY += ballMoveY;
                    }
                    else 
                    {
                        /* 
                         * A Physics Background may be required to understand what is happening.
                         * 
                         * In short, when snipeMode is on, the ball zips to the nearest brick.
                         * snipeMode is normally activated when the ball 
                         * 
                         * The physics explanation:
                            * The program gets the x and y component based on the ball's position
                                from the brick. 
                            * The trajectory is gotten from using the inverse Tangent function.
                            * the x trajectory is 
                         * 
                         * 
                         * The result:
                            * The result ended up with an interesting behavior of the ball.
                            * The ball immediately zips to the y axis or x axis of the brick,
                                then slowly closes the gap, taps the brick, and repeats
                                for the remaining bricks
                            * When the ballSpeed is too fast, the ball appears to quiver up and down.
                                I am not entirely sure why, but I set the ballSpeed to 1 everytime
                                the ball enters snipeMode.
                         * 
                         * Note that this result was better than what I originally planned.
                         * Most of this was using what I learned in Physics and testing it out.
                         * 
                         * This result took about 2 hours to create and conceptualize.
                         * The physics class I am taking is paying off to some extent!
                         * 
                         */
                        //Reset the targetted brick if it's null or is invisible.
                        if(brickTarget == null || brickTarget.status == 0)
                        {
                            brickTarget = getVisibleBrick();
                        }
                        

                        //if ball is to the right of the brick. 
                        if(ballX > brickTarget.x)
                        {
                            //if ball is below brick.
                            if(ballY > brickTarget.y)
                            {
                                //the distance the ball is from a brick on the x axis.
                                trajX = ballX - brickTarget.x;
                                //the distance the ball is from a brick on the y axis.
                                trajY = ballY - brickTarget.y;
                                
                                //find the angle above the x-axis that the ball should be headed.
                                vectorAngle = Math.atan(trajX/trajY);

                                //The angle adds up to 90 degrees, so we divide by 90 to get the 
                                //x and y force components.
                                //X goes left.
                                trajX = -(vectorAngle/90) * ballSpeed * (trajX/trajY);
                                //Y goes up
                                //trajY = ((vectorAngle/90) - 1) * ballSpeed;
                                trajY = -((90-vectorAngle)/90) * ballSpeed;


                                ballMoveX = trajX;
                                ballMoveY = trajY;
                            }
                            else //ball is above brick.
                            {
                                trajX = ballX - brickTarget.x;
                                trajY = ballY + brickTarget.y;
                                
                                //find the angle above the x-axis that the ball should be headed.
                                vectorAngle = Math.atan(trajX/trajY);

                                //The angle adds up to 90 degrees, so we divide by 90 to get the 
                                //x and y force components.
                                //X goes left.
                                trajX = -(vectorAngle/90) * ballSpeed * (trajX/trajY);
                                //Y goes down.
                                //trajY = (1 - (vectorAngle/90)) * ballSpeed;
                                trajY = ((90-vectorAngle)/90) * ballSpeed;
                                
                                ballMoveX = trajX;
                                ballMoveY = trajY;
                            }

                        }
                        else //ball is to the left of the brick. 
                        {
                            //if ball is below brick.
                            if(ballY > brickTarget.y)
                            {
                                trajX = ballX + brickTarget.x;
                                trajY = ballY - brickTarget.y;
                                
                                //find the angle above the x-axis that the ball should be headed.
                                vectorAngle = Math.atan(trajX/trajY);

                                //The angle adds up to 90 degrees, so we divide by 90 to get the 
                                //x and y force components.
                                //X is going right.
                                trajX = (vectorAngle/90) * ballSpeed * (trajX/trajY);
                                //Y is going up.
                                //trajY = ((vectorAngle/90) - 1) * ballSpeed;
                                trajY = -((90-vectorAngle)/90) * ballSpeed;
                                
                                ballMoveX = trajX;
                                ballMoveY = trajY;
                            }
                            else //ball is above brick.
                            {
                                trajX = ballX + brickTarget.x;
                                trajY = ballY + brickTarget.y;
                                
                                //find the angle above the x-axis that the ball should be headed.
                                vectorAngle = Math.atan(trajX/trajY);

                                //The angle adds up to 90 degrees, so we divide by 90 to get the 
                                //x and y force components.
                                //X is going right.
                                trajX = (vectorAngle/90) * ballSpeed * (trajX/trajY);
                                //Y is going down.
                                //trajY = (1 - (vectorAngle/90)) * ballSpeed;
                                trajY = ((90-vectorAngle)/90) * ballSpeed;
                                
                                ballMoveX = trajX;
                                ballMoveY = trajY;
                            }
                            
                        }
                        //updateSpeed();
                        //Move the ball horizontally according to ballMoveX.
                        ballX += ballMoveX;
                        //Move the ball vertically according to ballMoveY.
                        ballY += ballMoveY;
                    }

                

                /***** Paddle Logic *****/
                if(rightPressed)
                {
                    paddleX += 7;
                    if(paddleX + paddleWidth > canvas.width)
                    {
                        paddleX = canvas.width - paddleWidth;
                    }
                }
                else if(leftPressed)
                {
                    paddleX -= 7;
                    if(paddleX < 0)
                    {
                        paddleX = 0;
                    }
                }

                    // Paddle Logic for Auto-Mode
                    if(autoMode)
                    {
                        paddleX = ballX - paddleWidth/2;
                    }

                    //Paddle Logic for Increasing Width.
                    if(paddleScore >= 10)
                    {
                        paddleWidth++;
                        paddleScore = paddleScore - 10;
                    }

                    //Logic for Wombo Combo
                    //If womboCombo is not already 0 and
                    //the ball is below 2/3 of the screen.
                    if(womboCombo != 0 && ballY > ((2*canvas.height)/3))
                    {
                        if(womboCombo > 2)
                        {
                            console.log(`Wombo Combo! You hit ${womboCombo} bricks in 1 go!`);
                            womboCombo = 0;
                        }
                    }


                drawHitMarker(); //Draw a hitmarker every frame to mark the most recently-hit brick.
                  

                frameCount++;


                requestAnimationFrame(draw);
            }

            function getVisibleBrick()
            {
                //console.log("Got a Visible Brick.");
                for(let c = 0; c < brickColumnCount; c++)
                {
                    for(let r = 0; r < brickRowCount; r++)
                    {
                        const brick = bricks[c][r];
                        if(brick.status === 1)
                        {
                            return brick;
                        }
                    }
                }
            }

            function drawBackgroundImage()
            {
                canvasContext.drawImage(mlgbackground, mlgbackgroundX, mlgbackgroundY, canvas.width, canvas.height);
            }

            function drawBall()
            {
                /*** The following code will draw a small blue circle ***/
                canvasContext.beginPath();
                //draw the circle.
                //The circle starts:
                    //50px from the left side of the screen,
                    //50px from the top of the screen, 
                    //10px for the arc radius
                    //Math.PI*2 for the start angle and end angle (must be in radians)
                canvasContext.arc(ballX, ballY, ballRadius, 0, Math.PI*2);
                //make the pen change to blue-cola-colored ink.
                canvasContext.fillStyle = ballColor;
                //make the pen change to blue-cola-colored ink.
                canvasContext.fill();
                canvasContext.closePath();

                
            }

            function drawPaddle() 
            {
                canvasContext.beginPath();
                canvasContext.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
                canvasContext.fillStyle = themeColor;
                canvasContext.fill();
                canvasContext.closePath();
            }

            function keyDownHandler(e)
            {
                if (e.key === "Right" || e.key === "ArrowRight")
                {
                    rightPressed = true;
                } 
                else if (e.key === "Left" || e.key === "ArrowLeft")
                {
                    leftPressed = true;
                }
            }

            function keyUpHandler(e)
            {
                if (e.key === "Right" || e.key === "ArrowRight")
                {
                    rightPressed = false;
                } 
                else if (e.key === "Left" || e.key === "ArrowLeft")
                {
                    leftPressed = false;
                }
                else if (e.key === "P" || e.key === "p")
                {
                    pauseGame();
                }
            }

            function mouseMoveHandler(e)
            {
                //relativeX is equal to the horizontal mouse position - 
                //distance between the left edge of the canvas and viewport (offsetLeft).
                const relativeX = e.clientX - canvas.offsetLeft;
                if(relativeX > 0 && relativeX < canvas.width)
                {
                    paddleX = relativeX - paddleWidth/2;
                }
            }

            function drawHitMarker()
            {
                canvasContext.drawImage(hitmarker, hitmarkerX, hitmarkerY);
            }


            function drawBricks() 
            {
                for (let c = 0; c < brickColumnCount; c++)
                {
                    for(let r = 0; r < brickRowCount; r++)
                    {
                        if(bricks[c][r].status === 1)
                        {
                            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
    
                            bricks[c][r].x = brickX;
                            bricks[c][r].y = brickY;
                            canvasContext.beginPath();
                            canvasContext.rect(brickX, brickY, brickWidth, brickHeight);
                            canvasContext.fillStyle = "#4ba3a7";
                            canvasContext.fill();
                            canvasContext.closePath();
                        }
                    }
                }
            }

            function collisionDetection()
            {
                for(let c = 0; c < brickColumnCount; c++)
                {
                    for(let r = 0; r < brickRowCount; r++)
                    {
                        const brick = bricks[c][r];
                        if(brick.status === 1)
                        {
                            //The brick collision.
                            if(
                                ballX + ballRadius >= brick.x && 
                                ballX - ballRadius <= brick.x + brickWidth &&
                                ballY + ballRadius >= brick.y && 
                                ballY - ballRadius <= brick.y + brickHeight)
                            {
                                //(brick.x and brick.y are the top left points of the brick)
                                //We hit the ball, add a point, and make the brick disappear.
                                brick.status = 0;

                                //Specify the collision. 
                                //This specifies the ball hitting the top/bottom part of the brick.
                                if(!pwnMode)
                                {
                                    if(ballY - ballRadius >= brick.y+brickHeight || ballY + ballRadius <= brick.y)
                                    {
                                        ballMoveY = -ballMoveY;
                                    }
                                    else
                                    {
                                        ballMoveX = -ballMoveX;
                                    }
                                }


                                score+=ballSpeed;
                                paddleScore=ballSpeed;
                                hitmarkerX = brick.x + (brickWidth/2) - (hitmarker.width/2);
                                hitmarkerY = brick.y + (brickHeight/2) - (hitmarker.height/2);

                                drawHitMarker(hitmarkerX, hitmarkerY);
                                //drawHitMarker(hitmarker.x, hitmarker.y);
                                playHitsound();
                                bricksLeft--;
                                womboCombo++;

                                //If there are less than half of the bricks remaining.
                                if(bricksLeft < Math.round(brickColumnCount*brickRowCount*(0.5)))
                                {
                                    pwnMode = true;
                                }
                                //If there are less than 1/8 of the bricks remaining.
                                if(bricksLeft < Math.round(brickColumnCount*brickRowCount*(0.125)))
                                {
                                    snipeMode = true;

                                    if(ballSpeed != 1)
                                    {
                                        ballSpeedRemember = ballSpeed;
                                        //console.log("Ball speed before snipeMode: " + ballSpeedRemember);
                                        ballSpeed = 1;
                                        updateSpeed();
                                    }

                                }

                                
                                if(bricksLeft == 0)
                                {
                                    for(let c = 0; c < brickColumnCount; c++)
                                    {
                                        for(let r = 0; r < brickRowCount; r++)
                                        {
                                            const brick = bricks[c][r];
                                            brick.status = 1;
                                        }
                                    }
                                    bricksLeft = brickColumnCount * brickRowCount;
                                    lives++;
                                    pwnMode = false;
                                    snipeMode = false;
                                    ballSpeed = ballSpeedRemember;
                                    //console.log("Ball speed after snipeMode: " + ballSpeed);
                                    updateSpeed();
                                    //alert("YOU WIN, CONGRATULATIONS!");
                                    //document.location.reload();
                                    //clearInterval(interval); //Needed for Chrome to end game.
                                }


                                // Get a random number to determine the color of 
                                //the ball when it collides with a brick.
                                //The randon number ranges from 1-5.
                                var randomNumber = Math.round((Math.random() * 5) + 1);


                                //Change the color of the ball randomly.
                                switch(randomNumber)
                                {
                                    case 1:
                                        ballColor = lgreen;
                                        break;
                                    case 2: 
                                        ballColor = green;
                                        break;
                                    case 3: 
                                        ballColor = dblue;
                                        break;
                                    case 4: 
                                        ballColor = purple;
                                        break;
                                    default:
                                        ballColor = cyan;
                                        break;
                                }
                            }
                        }
                    }
                }
            }

            hitSoundIteration = 0;
            function playHitsound()
            {
                /*
                 * There is a reason why this function was created.
                 * Problem: When the ball hits multiple blocks very quickly, 
                 * the program can't play multiple hitmarkersounds. 
                 *
                 * Solution: This code tries to alleviate this problem 
                 * by having multiple audio tracks.
                 * Based on my research, Howler.js is an option rather than
                 * this approach. However, the only downside is that it requires
                 * a download. I want this project to be download-free.
                 * So, I opted for this rudimentary approach.
                 *
                 * 
                 * https://howlerjs.com/
                 * Benefits over Web Audio API
                 * - Audio Sprites
                 * - Full Codec Support: MP3, MPEG, OPUS, OGG, OGA, WAV, AAC,
                 *   CAF, M4A, MP4, WEBA, WEBM, DOLBY, FLAC.
                 * - More versatile and compatible with older browsers like IE9.
                 * - Auto Caching for better performance and bandwidth.
                 * - Lightweight (7KB) and is 100% JavaScript. No Dependencies.
                 * - More.
                 * 
                 */
                if(!snipeMode)
                {
                    switch(hitSoundIteration)
                    {
                        case 0:
                            hitsound.play();
                            break;
                        case 1:
                            hitsound2.play();
                            break;
                        case 2:
                            hitsound3.play();
                            break;
                        case 3: 
                            hitsound4.play();
                            break;
                        case 4: 
                            hitsound5.play();
                            break;
                        case 5: 
                            hitsound6.play();
                            break;
                        default: 
                            hitsound.play();
                            hitSoundIteration = 0;
                    }
                }
                else
                {
                    switch(hitSoundIteration)
                    {
                        case 0:
                            snipersound.play();
                            break;
                        case 1:
                            snipersound2.play();
                            break;
                        case 2:
                            snipersound.play();
                            break;
                        case 3: 
                            snipersound2.play();
                            break;
                        case 4: 
                            snipersound.play();
                            break;
                        case 5: 
                            snipersound2.play();
                            break;
                        default: 
                            snipersound.play();
                            snipersound2.play();
                            hitSoundIteration = 0;
                    }
                }
                hitSoundIteration++;

                //The code if I decided to use Howler.js. Incredibly simple.
                /* var sound = new Howl({
                    urls: ['hitmarkersound.mp3']
                  }).play(); */
            }

            function drawScore() 
            {
                canvasContext.font = "16px sans-serif";
                canvasContext.fillStyle = themeColor;
                canvasContext.fillText(`Score: ${score}`, 8, 20);
            }

            function drawSpeed()
            {
                speedText = getTextWidth(`Speed: ${ballSpeed}`, "16px sans-serif");

                canvasContext.font = "16px sans-serif";
                canvasContext.fillStyle = "#FFFFFF";
                canvasContext.fillText(`Speed: ${ballSpeed}`, (canvas.width/2) - (speedText/2), 20);
            }

            function drawLives() 
            {
                canvasContext.font = "16px sans-serif";
                canvasContext.fillStyle = themeColor;
                canvasContext.fillText(`Lives: ${lives}`, canvas.width - 65, 20);
            }

            function drawBricksLeft()
            {
                canvasContext.font = "16px sans-serif";
                canvasContext.fillStyle = "#FFFF00";
                canvasContext.fillText(`Bricks Left: ${bricksLeft}`, 140, canvas.height - 20);
            }


            function drawTitle()
            {
                //Determine the size of the Title text.
                titleTextSize = getTextWidth(`MLG Breakout`, "bold 40px sans-serif");

                //Draw the Title.
                canvasContext.font = "bold 40px sans-serif";
                canvasContext.fillStyle = "#000000";
                canvasContext.fillText(`MLG Breakout`,(canvas.width/2) - (titleTextSize/2), 150);

                //Determine the size of the starting text.
                startingTextSize = getTextWidth(`Click Anywhere to Begin Pwnage.`, "italic bold 20px sans-serif");

                //Draw text showing how to start the game.
                canvasContext.font = "italic bold 20px sans-serif";
                canvasContext.fillStyle = "#333333";
                canvasContext.fillText(`Click Anywhere to Begin Pwnage.`, (canvas.width/2) - (startingTextSize/2), 350);

            }

            function drawMLGBooleans()
            {
                //Determine the size of the MLG text.
                mlgTextSize = getTextWidth(`[ Auto Mode: ${autoMode} | PWN Mode: ${pwnMode} | Snipe Mode: ${snipeMode} ]`, "italic bold 16px sans-serif");

                autoModeTextSize = getTextWidth(`[ Auto Mode: ${autoMode} | `, "italic 16px sans-serif");
                pwnModeTextSize = getTextWidth(`PWN Mode: ${pwnMode} | `, "italic 16px sans-serif");
                snipeModeTextSize = getTextWidth(`Snipe Mode: ${snipeMode} ]`, "italic 16px sans-serif");

                //Affect the color of the text.
                canvasContext.fillStyle = "#000000";

                //Determine the font, size, and text renders for the canvas context.
                canvasContext.font = "italic 16px sans-serif";


                //The x where the string will begin.
                //It starts 2/3 from the left of the canvas minus half of the entire string.
                booleanStartX = (2*canvas.width/3) - (mlgTextSize/2);



                //Adjust the size of the text if it's bold.
                if(autoMode)
                {
                    autoModeTextSize = getTextWidth(`[ Auto Mode: ${autoMode} | `, "italic bold 16px sans-serif");
                    canvasContext.font = "italic bold 16px sans-serif";
                }
                else 
                {
                    canvasContext.font = "italic 16px sans-serif";
                }
                canvasContext.fillText(`[ Auto Mode: ${autoMode} | `, booleanStartX, canvas.height - 20);


                //Adjust the size of the text if it's bold.
                if(pwnMode)
                {
                    pwnModeTextSize = getTextWidth(`PWN Mode: ${pwnMode} | `, "italic bold 16px sans-serif");
                    canvasContext.font = "italic bold 16px sans-serif";
                }
                else 
                {
                    canvasContext.font = "italic 16px sans-serif";
                }
                canvasContext.fillText(`PWN Mode: ${pwnMode} | `, booleanStartX + autoModeTextSize, canvas.height - 20);

                
                
                //Adjust the size of the text if it's bold.
                if(snipeMode)
                {
                    snipeModeTextSize = getTextWidth(`Snipe Mode: ${snipeMode} ]`, "italic bold 16px sans-serif");
                    canvasContext.font = "italic bold 16px sans-serif";
                }
                else 
                {
                    canvasContext.font = "italic 16px sans-serif";
                }
                canvasContext.fillText(`Snipe Mode: ${snipeMode} ]`, booleanStartX + autoModeTextSize + pwnModeTextSize, canvas.height - 20);



                //canvasContext.fillText(`[ Auto Mode: ${autoMode} | PWN Mode: ${pwnMode} | Snipe Mode: ${snipeMode} ]`, booleanStartX, canvas.height - 20);
            }



            /* This function will be called whenever the user clicks on the start screen to begin the game. (Activated by mousedown) */
            function beginGame()
            {
                //replace the event listener with a function that increases the speed.
                document.removeEventListener("click", beginGame, false);
                document.addEventListener("click", increaseSpeed, false);

                backgroundMusic.play();

                //Begin Drawing Shapes for the Game.
                draw();
            }

            //right-click to lower speed
            document.oncontextmenu = function(e){
                var evt = new Object({keyCode:93});
                //Ensure ballSpeed is 0. 
                //Negative ballSpeed works, but breaks the game functionality like score.
                if(ballSpeed >= 1)
                {
                    ballSpeed--;
                }
                updateSpeed();
                if(event.preventDefault != undefined)
                    event.preventDefault();
                if(event.stopPropagation != undefined)
                    event.stopPropagation();
            }

            //left-click to increase speed.
            function increaseSpeed()
            {
                ballSpeed++;
                updateSpeed();
            }

            function updateSpeed()
            {
                //if ball is moving right
                if(ballMoveX > 0)
                {
                    ballMoveX = ballSpeed;
                }
                else //ball is moving left
                {
                    ballMoveX = -ballSpeed;
                }

                //if the ball is moving down.
                if(ballMoveY > 0)
                {
                    ballMoveY = ballSpeed;
                }
                else //ball is moving up.
                {
                    ballMoveY = -ballSpeed;
                }
            }

            //Thanks to: https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript
            //This function calculates the width of a text given its font, font size, and bold/italic/etc.
            function getTextWidth(text, font) 
            {
                // re-use canvas object for better performance
                const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
                const context = canvas.getContext("2d");
                context.font = font;
                const metrics = context.measureText(text);
                return metrics.width;
            }

            function pauseGame()
            {
                if(!isPaused)
                {
                    ballSpeedRemember = ballSpeed;
                    ballMoveXRemember = ballMoveX;
                    ballMoveYRemember = ballMoveY;
                    ballSpeed = 0;
                    isPaused = true;
                }
                else 
                {
                    ballSpeed = ballSpeedRemember;
                    ballMoveX = ballMoveXRemember;
                    ballMoveY = ballMoveYRemember;
                    isPaused = false;
                }
            }

            function toggleAutoMode(e)
            {
                // Thanks to https://stackoverflow.com/questions/21224327/how-to-detect-middle-mouse-button-click
                // e.which == 2 is the one that allows a middle click.
                if (e.which == 2 || e.button == 4)
                {
                    console.log('Middle Click Detected - Activating Auto Mode');
                    if(autoMode)
                    {
                        autoMode = false;
                    }
                    else 
                    {
                        autoMode = true;
                    }

                }
            }

            /****************** END FUNCTIONS *****************/
            /****************** ASYNC FUNCTION CALLS *****************/

            document.addEventListener("keydown", keyDownHandler, false);
            document.addEventListener("keyup", keyUpHandler, false);
            document.addEventListener("mousemove", mouseMoveHandler, false);

            document.addEventListener("click", beginGame, false);
            document.addEventListener("auxclick", toggleAutoMode, false);

            drawTitle();
            
            /****************** END ASYNC FUNCTION CALLS *****************/
        </script>
    </body>
</html>